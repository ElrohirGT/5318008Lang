try{
	let a = 0;
	let b = 3 / a;
} catch (err) {
	print("ups");
}
---
# Code generated by 5318008Lang compiler.
# Checkout our repository here: https://github.com/ElrohirGT/5318008Lang
# The following code is designed to run on the compiler: https://cpulator.01xz.net/?sys=mipsr5-spim
.data
panic_prefix:		.asciiz		"panic: "
zero_division_exception:		.asciiz		"division by zero"
idx_out_of_range_exception:		.asciiz		"idx out of range"
err_pointer:		.word		0

.text
# Main start of our program
.global _start
_start:
	jal main
	li $v0, 10
	syscall		# Use syscall 10 to stop simulation

main:
	addiu $sp, $sp, -36
# GOTO GLOBAL_0_EXC
	b GLOBAL_0_EXC
# SEC GLOBAL_0_EXC_RETURN:
GLOBAL_0_EXC_RETURN:
# END
	addiu $sp, $sp, 36
	jr $ra
# 
# SEC GLOBAL_0_EXC:
GLOBAL_0_EXC:
# 	= err u32 0
	li $t0, 0
	sw $t0, 0($sp)
# 	GOTO GLOBAL_0_EXC_TRY
	b GLOBAL_0_EXC_TRY
# SEC GLOBAL_0_EXC_CATCH:
GLOBAL_0_EXC_CATCH:
# 	REFERENCE err err_pointer
	la $t0, err_pointer
	sw $t0, 0($sp)
# 	ALLOC t5 4
	la $t0, 8($sp)
	sw $t0, 4($sp)
# 	SBO t5 0 117
	li $t0, 0
	li $t1, 117
	lw $t2, 4($sp)
	addu $t2, $t2, $t0
	sb $t1, 0($t2)
# 	SBO t5 1 112
	li $t0, 1
	li $t1, 112
	lw $t2, 4($sp)
	addu $t2, $t2, $t0
	sb $t1, 0($t2)
# 	SBO t5 2 115
	li $t0, 2
	li $t1, 115
	lw $t2, 4($sp)
	addu $t2, $t2, $t0
	sb $t1, 0($t2)
# 	SBO t5 3 0
	li $t0, 3
	li $t1, 0
	lw $t2, 4($sp)
	addu $t2, $t2, $t0
	sb $t1, 0($t2)
# 	// "ups"
# 	PARAM t5
	lw $t0, 4($sp)
	sw $s0, 12($sp)
	move $s0, $t0
# 	// print("ups")
# 	CALL print 1
	sw $ra, 32($sp)
	jal print
	lw $ra, 32($sp)
	lw $s0, 12($sp)
# 	GOTO GLOBAL_0_EXC_RETURN
	b GLOBAL_0_EXC_RETURN
# SEC GLOBAL_0_EXC_TRY:
GLOBAL_0_EXC_TRY:
# 	= t1 i32 0
	li $t0, 0
	sw $t0, 12($sp)
# 	= err u32 0
	li $t0, 0
	sw $t0, 0($sp)
# 	= addr u32 0
	li $t0, 0
	sw $t0, 16($sp)
# 	REFERENCE err zero_division_exception
	la $t0, zero_division_exception
	sw $t0, 0($sp)
# 	REFERENCE addr err_pointer
	la $t0, err_pointer
	sw $t0, 16($sp)
# 	SWO addr 0 err
	li $t0, 0
	lw $t1, 0($sp)
	lw $t2, 16($sp)
	addu $t2, $t2, $t0
	sw $t1, 0($t2)
# 	EQ t3 t1 0
	lw $t0, 12($sp)
	li $t1, 0
	seq $t2, $t0, $t1
# 	IF t3 GOTO GLOBAL_0_EXC_CATCH
	bne $t2, $zero, GLOBAL_0_EXC_CATCH
# 	DIV t2 3 t1
	li $t2, 3
	lw $t0, 12($sp)
	div $t2, $t0
	mflo $t1
# 	= t4 i32 t2
	sw $t1, 20($sp)
# 	GOTO GLOBAL_0_EXC_RETURN
	b GLOBAL_0_EXC_RETURN

_EXCEPTION_HANDLER:
	la   $a0, panic_prefix
	li   $v0, 4
	syscall

	lw   $a0, err_pointer
	li   $v0, 4
	syscall

	li   $a0, 10
	li   $v0, 11
	syscall

	li   $v0, 10
	syscall